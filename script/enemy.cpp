//======================================================================================================================
//
// 敵の処理[enemy.cpp]
// Author:RYO KANDA
//
//======================================================================================================================
#include "manager.h"
#include "enemy.h"

#include "game.h"

#include "bullet.h"
#include "explosion.h"
#include "score.h"

//======================================================================================================================
// マクロ定義
//======================================================================================================================
#define ENEMY_TYPE		(2)

#define ENEMY_SPEED		(5.0f)
#define ENEMY_JUMPSPEED	(0.9f)

//======================================================================================================================
// プロトタイプ宣言
//======================================================================================================================

//======================================================================================================================
// メンバ変数
//======================================================================================================================
LPDIRECT3DTEXTURE9 CEnemy::m_pTexture[ENEMY_TYPE] = {};
int CEnemy::nNumEnemy = 0;

// コンストラクタ
CEnemy::CEnemy() : CScene2D::CScene2D(OBJTYPE_ENEMY)
{
	nNumEnemy++;
}

// デストラクタ
CEnemy::~CEnemy()
{

}

HRESULT CEnemy::Load()
{
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();

	//テクスチャの読み込み
	D3DXCreateTextureFromFile(pDevice, "data/TEXTURE/enemy_00.png", &m_pTexture[0]);
	D3DXCreateTextureFromFile(pDevice, "data/TEXTURE/enemy_01.png", &m_pTexture[1]);

	for (int nCnt = 0; nCnt < ENEMYTYPE_MAX; nCnt++)
	{
		if (m_pTexture[nCnt] == NULL)
		{
			return -1;
		}
	}

	return S_OK;
}

void CEnemy::Unload()
{
	for (int nCnt = 0; nCnt < ENEMYTYPE_MAX; nCnt++)
	{
		//テクスチャの開放
		if (m_pTexture[nCnt] != NULL)
		{
			m_pTexture[nCnt]->Release();
			m_pTexture[nCnt] = NULL;
		}
	}
}

//======================================================================================================================
// 生成
//======================================================================================================================
CEnemy *CEnemy::Create(D3DXVECTOR3 pos, ENEMYTYPE type, float fspeed)
{
	CEnemy *pEnemy;

	pEnemy = new CEnemy;

	pEnemy->SetPos(pos);
	pEnemy->m_Type = type;

	pEnemy->Init();

	pEnemy->m_fSpeed = fspeed;
	pEnemy->BindTexture(m_pTexture[type]);

	return pEnemy;
}

//======================================================================================================================
// 初期化
//======================================================================================================================
void CEnemy::Init()
{
	CScene2D::Init();

	if (m_Type == ENEMYTYPE_PART1)
	{
		SetSize(D3DXVECTOR3(150.0f, 200.0f, 0.0f));
		SetTextureAnimationTex(2, 4);
	}
	else if (m_Type == ENEMYTYPE_PART2)
	{
		SetSize(D3DXVECTOR3(300.0f, 150.0f, 0.0f));
	}

	m_nTime = rand() % 360;
	m_fSpeed = 1.0f;
}

//======================================================================================================================
// プレイヤの開放処理
//======================================================================================================================
void CEnemy::Uninit()
{
	nNumEnemy--;

	CScene2D::Uninit();

	this->Release();
}

//======================================================================================================================
// 更新処理
//======================================================================================================================
void CEnemy::Update()
{
	if (m_Type == ENEMYTYPE_PART1)
	{
		SetTextureAnimation(5, false);
	}

	D3DXVECTOR3 pos = GetPos();

	MoveSpeedEnemy();
	
	m_move.x -= m_move.x * 1 / 3;
	m_move.y -= m_move.y * 1 / 3;

	// 向きの処理
	Rot();

	if (fabsf(m_move.x) < 0.1f)
	{
		m_move.x = 0;
	}
	if (fabsf(m_move.y) < 0.1f)
	{
		m_move.y = 0;
	}

	SetPos(pos + m_move);

	if (GetPos().y + GetSize().y <= 0.0f)
	{
		Uninit();
	}
}

//======================================================================================================================
// 描画処理
//======================================================================================================================
void CEnemy::Draw()
{
	CScene2D::Draw();
}

//======================================================================================================================
// 被弾処理
//======================================================================================================================
void CEnemy::HitEnemy()
{
	// 爆発生成
	CExplosion::Create(GetPos());

	CGame::AddGameScore(3000);

	this->Uninit();
}

//======================================================================================================================
// 移動処理
//======================================================================================================================
void CEnemy::MoveSpeedEnemy()
{
	m_nTime++;

	switch (m_Type)
	{
	case ENEMYTYPE_PART1:
		m_move += D3DXVECTOR3(-1.0f, cos(m_nTime * D3DX_PI / 30.0f) * 0.5f, 0.0f) * m_fSpeed;
		break;

	case ENEMYTYPE_PART2:
		m_move += D3DXVECTOR3(-3.0f, cos(m_nTime * D3DX_PI / 90.0f) * 1.0f, 0.0f) * m_fSpeed;
		break;
	}
}

//======================================================================================================================
// 弾の発射
//======================================================================================================================
void CEnemy::BulletShot()
{
	CKeyboard *pKey = CManager::GetInputKeyboard();

	//if (pKey->GetKeyboardPress(DIK_SPACE))
	{

	}
}

//======================================================================================================================
// 敵数の取得
//======================================================================================================================
int CEnemy::GetNumEnemy()
{
	return nNumEnemy;
}
